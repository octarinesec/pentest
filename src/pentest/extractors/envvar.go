package extractors

import (
	"errors"
	"os"
	"pentest/engine"
	"pentest/extractors/env_matchers"
	"strings"
)

type EnvVarExtractor struct{}

func SplitEnviron(env string) (string, string, error) {
	if len(env) == 0 {
		return "", "", errors.New("Env is empty string!")
	}

	parts := strings.SplitN(env, "=", 2)

	if len(parts) == 1 {
		return parts[0], "", nil
	}

	return parts[0], parts[1], nil
}

func (EnvVarExtractor) Extract() {
	for _, e := range os.Environ() {
		key, value, err := SplitEnviron(e)
		if err != nil {
			engine.Logger.Warningf("Error while parsing environ \"%v\": %v\n", e, err)
			continue
		}
		engine.Logger.Debugf("Extracting info from env var: (%v, %v)\n", key, value)

		for _, matcher := range env_matchers.GetMatchers() {
			engine.Logger.Debugf("Matching entry using %T\n", matcher)
			matcher.Match(key, value)
		}
	}
}

func (e EnvVarExtractor) Summary() {
	var ips []string
	var ports []uint16
	var usernames []string
	var passwords []string

	for _, matcher := range env_matchers.GetMatchers() {
		ips = append(ips, engine.GetIPsByOrigin(matcher)...)
		ports = append(ports, engine.GetPortsByOrigin(matcher)...)
		usernames = append(usernames, engine.GetUsernamesByOrigin(matcher)...)
		passwords = append(passwords, engine.GetPasswordsByOrigin(matcher)...)
	}

	engine.Logger.Infof("IPs extracted using %T:", e)
	for _, ip := range ips {
		engine.Logger.Infof("    %s", ip)
	}
	engine.Logger.Infof("Ports extracted using %T:", e)
	for _, port := range ports {
		engine.Logger.Infof("    %d", port)
	}
	engine.Logger.Infof("Usernames extracted using %T:", e)
	for _, username := range usernames {
		engine.Logger.Infof("    %s", username)
	}
	engine.Logger.Infof("Passwords extracted using %T:", e)
	for _, password := range passwords {
		engine.Logger.Infof("    %s", password)
	}

}

func init() {
	engine.Logger.Debugf("Adding EnvVar Extractor")
	engine.AddExtractor(EnvVarExtractor{})
}
