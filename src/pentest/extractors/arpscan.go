package extractors

import (
	"github.com/mdlayher/arp"
	"net"
	"pentest/engine"
	"time"
)

type ArpScanExtractor struct{}

type subnetInterface struct {
	subnet   net.IPNet
	iface    net.Interface
}

func getSubnets() []subnetInterface {
	ifaces, err := net.Interfaces()
	if err != nil {
		engine.Logger.Debugf("Couldn't get interfaces for arp scanner: %v", err)
		return nil
	}

	var res []subnetInterface

	for _, i := range ifaces {
		addrs, err := i.Addrs()
		if err != nil {
			engine.Logger.Debugf("Couldn't get address from interface %v: %v", i, err)
			continue
		}

		for _, addr := range addrs {
			switch v := addr.(type) {
			case *net.IPNet:
				ipv4 := v.IP.To4()
				if ipv4 != nil {
					res = append(res, subnetInterface{*v, i})
				}
			}
		}
	}
	return res
}

func hostsFromSubnet(ipnet net.IPNet) []net.IP {
	var ips []net.IP
	for ip := ipnet.IP.Mask(ipnet.Mask); ipnet.Contains(ip); ip = inc(ip) {
		if !ip.IsLoopback() && !ip.IsGlobalUnicast() {
			ips = append(ips, ip)
		}
	}
	// remove network address and broadcast address
	return ips
}

func inc(ip net.IP) net.IP {
	res := make(net.IP, len(ip))
	copy(res, ip)

	for j := len(res) - 1; j >= 0; j-- {
		res[j]++
		if res[j] > 0 {
			break
		}
	}
	return res
}

func scanSubnet(subnet subnetInterface) ([]net.IP, error) {
	engine.Logger.Infof("Scanning subnet %s", subnet.subnet.String())

	client, err := arp.Dial(&subnet.iface)
	if err != nil {
		engine.Logger.Debugf("Couldn't open iface for arp: %v", err)
		return nil, err
	}
	defer client.Close()

	var ips []net.IP
	for _, ip := range hostsFromSubnet(subnet.subnet) {
		engine.Logger.Debugf("IP: %s", ip.String())

		if err := client.SetDeadline(time.Now().Add(time.Millisecond * 100)); err != nil {
			engine.Logger.Debugf("Couldn't set timeout for arp: %v", err)
			return nil, err
		}

		_, err := client.Resolve(ip)
		if err == nil {
			engine.Logger.Debugf("Exists!", ip.String())
			ips = append(ips, ip)
		}
	}

	return ips, nil
}

func (e ArpScanExtractor) Extract() {
	subnets := getSubnets()

	for _, subnet := range subnets {
		if subnet.subnet.IP.IsGlobalUnicast() {
			ips, err := scanSubnet(subnet)
			if err == nil {
				for _, ip := range ips {
					engine.AddIP(ip.String(), e)
				}
			}
		}


	}
}

func (e ArpScanExtractor) Summary() {
	engine.Logger.Infof("IPs extracted using %T:", e)
	for _, ip := range engine.GetIPsByOrigin(e) {
		engine.Logger.Infof("    %s", ip)
	}
}

func init() {
	engine.Logger.Debugf("Adding ArpScanExtractor Extractor")

	engine.AddExtractor(ArpScanExtractor{})
}
