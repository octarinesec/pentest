package engine

import (
	"fmt"
	"net"
	"time"
)

type Target struct {
	IP   string
	Port uint16
}

func (t Target) String() string {
	return fmt.Sprintf("%s:%d", t.IP, t.Port)
}

var	ips   []OriginString
var	ports []OriginUint16

func AddIP(ip string, origin interface{}) {
	for _, exists := range ips {
		if exists.string == ip {
			return
		}
	}

	Logger.Debugf("Collecting ip: %v\n", ip)
	ips = append(ips, OriginString{Origin{origin}, ip})
}

func AddPort(port uint16, origin interface{}) {
	for _, exists := range ports {
		if exists.uint16 == port {
			return
		}
	}

	Logger.Debugf("Collecting port: %v\n", port)
	ports = append(ports, OriginUint16{Origin{origin}, port})
}

func GetIPsByOrigin(origin interface{}) []string {
	var res []string
	for _, ip := range ips {
		if ip.Origin.Origin == origin {
			res = append(res, ip.string)
		}
	}
	return res
}

func GetPortsByOrigin(origin interface{}) []uint16 {
	var res []uint16
	for _, port := range ports {
		if port.Origin.Origin == origin {
			res = append(res, port.uint16)
		}
	}
	return res
}

func IsTargetReachable(target Target) bool {
	conn, err := net.DialTimeout("tcp", target.String(), time.Millisecond*50)
	if err != nil {
		Logger.Debugf("Target %v isn't reachable", target)
		return false
	}
	conn.Close()

	return true
}

func GenerateTarget() <-chan Target {
	ch := make(chan Target)
	go func() {
		for _, ip := range ips {
			for _, port := range ports {
				target := Target{ip.string, port.uint16}
				if IsTargetReachable(target) {
					ch <- target
				}
			}
		}
		close(ch)
	}()
	return ch
}
